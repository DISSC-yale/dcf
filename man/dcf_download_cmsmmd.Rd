% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dcf_download_cmsmmd.R
\name{dcf_download_cmsmmd}
\alias{dcf_download_cmsmmd}
\alias{dcf_standardize_cmsmmd}
\title{Download Medicare Disparities Data}
\usage{
dcf_download_cmsmmd(
  measure,
  population = NULL,
  year = NULL,
  geography = NULL,
  adjust = NULL,
  condition = NULL,
  sex = c(1:2, "."),
  age = c(0:4, "."),
  race = c(1:6, "."),
  dual_elig = ".",
  medicare_elig = ".",
  refresh_codebook = FALSE,
  codebook_only = FALSE,
  row_limit = 9999999,
  out_file = NULL,
  state = NULL,
  parquet = FALSE,
  verbose = TRUE
)

dcf_standardize_cmsmmd(raw_data = NULL)
}
\arguments{
\item{measure}{Name or letter code of the measure to download.}

\item{population}{The population code; either \code{f} (Medicare Fee For Service) or
\code{m} (Medicare Advantage).}

\item{year}{Year(s) to download (e.g., \code{2015:2020}). If not specified, all available
years will be included.}

\item{geography}{Geography code(s) to include, between \code{n} (national), \code{s} (state),
and \code{c} (county). If not specified, all available geographies will be included.}

\item{adjust, condition, sex, age, race, dual_elig, medicare_elig}{One or more codes indicating
the variable levels to include (see \code{\link{dcf_standardize_cmsmmd}}).
If \code{"."}, values will be across all levels, whereas if \code{NULL}, all available levels
will be included (aggregated and disaggregated). See the Making Requests section.}

\item{refresh_codebook}{Logical; if \code{TRUE}, will re-download the codebook even if it
exists in the temporary location (which is cleared each R session).}

\item{codebook_only}{Logical; if \code{TRUE}, will return the codebook without downloading data.}

\item{row_limit}{Maximum number of rows to return in each request. The API limit appears to be 100,000.}

\item{out_file}{Path to the CSV or Parquet file to write data to.}

\item{state}{The codebook state (MD5 hash) recorded during a previous download;
if provided, will only download if the new state does not match.}

\item{parquet}{Logical; if \code{TRUE}, will convert the downloaded CSV file to Parquet.}

\item{verbose}{Logical; if \code{FALSE}, will not display status messages.}

\item{raw_data}{The raw data as downloaded with \code{dcf_download_cmsmmd} to be standardized.}
}
\value{
\code{dcf_download_cmsmmd}: A list:
\itemize{
  \item \strong{\code{codebook}}: The codebook.
  \item \strong{\code{codebook_state}}: MD5 hash of the codebook.
  \item \strong{\code{data}}: The downloaded data.
}

\code{dcf_standardize_cmsmmd}: If \code{raw_data} is \code{NULL}, a list
with an entry for each API parameter, containing named vectors with level codes as names
mapping to level values (as they appear in the tool's menus).
Otherwise, a version of \code{raw_data} with coded values converted to labels.
}
\description{
Download data from the Centers for Medicare & Medicaid Services (CMS)
\href{https://data.cms.gov/tools/mapping-medicare-disparities-by-population}{Mapping Medicare Disparities by Population} (MMD) tool.
}
\section{Making Requests}{

The API operates over several large files, partitioned by measure, year,
adjust, and dual and medicaid eligibility. These are identified with the codebook
(\code{dcf_download_cmsmmd(codebook_only = TRUE)}).

The files are larger than the API's limit, so requests for each file have to be broken up
by the other variables within them (sex, age, race, and condition).

For best performance, make requests as big as possible while staying under 100,000 rows
each (e.g., by setting \code{sex}, \code{age}, or \code{race} to \code{NULL}).
}

\examples{
# find the codes associated with menu values
variable_codes <- dcf_standardize_cmsmmd()
variable_codes[c(
  "sex", "age", "race",
  "adjust", "dual_elig", "medicare_elig"
)]

# look at the codebook which defines source files
codebook <- dcf_download_cmsmmd(codebook_only = TRUE)
codebook

\dontrun{
  # download data
  downloaded <- dcf_download_cmsmmd(
    "preventive care",
    population = "f",
    race = ".",
    sex = ".",
    age = NULL,
    condition = c(83, 85, 86, 88, 89, 95, 101, 102, 104, 105:107),
    adjust = 1
  )

  # convert codes to levels
  data_standard <- dcf_standardize_cmsmmd(downloaded$data)
}
}
